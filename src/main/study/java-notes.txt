Comparator vs Comparable
=====================================================================
Comparator and Comparable are both functional interfaces used for comparing object instances of same class.
Comparable is used when we want to keep the comparing logic internal to the class.
Comparable is a functional interface with a single method "compareTo".
The comparing object class needs to implement Comparable interface with comparing logic written inside compareTo method.
Return type of compareTo method is integer.

Comparator is used when we want to write the comparing logic external to the class.
The comparing logic is written inside "compare" method.
Return type of compare method is integer.
When compare(T x, T y), compare method returns-
    0: if (x==y)
    -1: if (x < y)
    1: if (x > y)

Functional Interfaces:
==========================
An interface is called functional when it has only one unimplemented/abstract method.
A functional interface can have additional methods with implementations but it should have only one
    unimplemented method.
These are designed to facilitate the use of lambda expressions.
We use @FunctionalInterface to ensure that an interface is functional, however usage of this annotation is optional.
Examples of functional interfaces in Java library-
1. Runnable
2. Comparable
3. Comparator
4. ActionListener
5. Predicate, Consumer, Function etc.

=========================================================
Variable arguments(var-args) are represented by ... in Java.
It allows to pass arbitrary number of arguments of same type to a method.

which of the following is valid
public static void main(String... a)        valid
public static void main(String...a)         valid
public static void main(String...[] a)      INVALID
public static void main(String[]... a)      valid
public static void main(String.* a)         INVALID

* forEach is a terminal operation which does not return a stream.
Predicate -
Match family - These methods take a predicate and tells us whether elements in stream
               match that predicate or not.
               There are three methods in this family
               anyMatch -  returns true if ANY of the elements matches predicate
               noneMatch - returns true if NONE of the elements matches predicate
               allMatch -  returns true if ALL the elements matches predicate

- To create a map from stream we use Collector.groupingBy('predicate for key')
- Collections factory methods:
    unmodifiableList
    unmodifiableMap
    unmodifiableSet
    unmodifiableCollection
- Above factory methods are allowed to read any changes in the base object but aren't allowed to
  make/write new changes.
- Map.copyOf() creates an unmodifiable object however unlike factory methods, changes to the base
  collection is not reflected in case of copyOf method.

Types of equality in Java-
Reference based - uses equals method from Object
Value based - checks for equality of values in fields, requires custom equals implementation
HashSet are based on HashMap and TreeSet are based on TreeSet.


https://docs.spring.io/spring-data/jpa/reference/repositories/query-keywords-reference.html
Repository query keywords :: Spring Data JPA
https://docs.spring.io/spring-data/jpa/reference/repositories/query-return-types-reference.html
Repository query return types :: Spring Data JPA
https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html
JPA Query Methods :: Spring Data JPA
OAuth2.0
https://developers.google.com/identity/openid-connect/openid-connect

What is circular reference issue in SpringBoot?
What is scope creep?

Spring Security
=============================================
https://capgemini.udemy.com/course/spring-security-zero-to-master/learn/lecture/44767239?kw=spring+security&src=sac#overview
https://github.com/eazybytes/spring-security